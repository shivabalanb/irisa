<!doctype html>
<meta charset="utf-8" />
<title>P2P WebRTC test (Rust signaling)</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    padding: 16px;
  }
  video {
    width: 48%;
    background: #d5d5d5;
    aspect-ratio: 16/9;
  }
  .row {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
  }
  #log {
    white-space: pre-wrap;
    background: #0b1020;
    color: #d6e4ff;
    padding: 8px;
    border-radius: 8px;
    max-height: 40vh;
    overflow: auto;
  }
  select {
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    margin: 0 4px;
  }
  label {
    font-weight: 500;
    margin-right: 8px;
  }
</style>

<h2>P2P</h2>
<div class="row">
  <input id="room" value="abc" />
  <button onclick="connect()">Connect</button>
  <button onclick="bye()">Bye</button>
  <button id="muteBtn" onclick="toggleMute()" disabled style="display: none">
    Mute Audio
  </button>
  <button id="videoToggleBtn" onclick="toggleVideo()" style="display: none">
    Disable Video
  </button>
  <span>Role: <b id="role">â€”</b></span>
</div>

<div class="row" id="deviceControls" style="display: none">
  <label>Camera:</label>
  <select id="videoSelect" onchange="changeVideoInput()"></select>
  <label>Microphone:</label>
  <select id="audioSelect" onchange="changeAudioInput()"></select>
</div>

<div class="row">
  <video id="local" playsinline muted></video>
  <video id="remote" playsinline></video>
</div>

<div id="iceInfo">
  <div>
    <strong>Connection Type:</strong> <span id="connectionType">â€”</span>
  </div>
</div>

<h3>Log</h3>
<pre id="log"></pre>

<script>
  const WS_URL =
    (location.protocol === "https:" ? "wss://" : "ws://") +
    location.host +
    "/ws";
  let ws,
    pc,
    localStream,
    role = null;
  let haveLocalMedia = false;
  let pendingIce = [];
  let isMuted = false;
  let iceCandidates = [];
  let activeCandidate = null;
  let availableDevices = [];
  let isVideoEnabled = true;

  const localEl = document.getElementById("local");
  const remoteEl = document.getElementById("remote");

  function setupWebRTCHandlers() {
    pc.ontrack = async (e) => {
      if (e.streams[0]) {
        const stream = e.streams[0];
        remoteEl.srcObject = stream;

        log(`received remote stream with ${stream.getTracks().length} tracks`);
        try {
          await remoteEl.play();
          log("âœ… remote video+audio playing successfully");
        } catch (err) {
          log("âŒ remote.play blocked:", err.message);
        }
      }
    };

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        iceCandidates.push({
          type: e.candidate.type,
          protocol: e.candidate.protocol,
          address: e.candidate.address,
          port: e.candidate.port,
          candidateType: e.candidate.candidateType || e.candidate.type,
        });
        send({ type: "ice", candidate: e.candidate });
      } else {
        log("ICE gathering complete");
      }
    };

    pc.onconnectionstatechange = () => {
      log(`[onconnectionstatechange] connection state: ${pc.connectionState}`);
      if (pc.connectionState === "connected") {
        log("âœ… Two-way communication established!");
        setTimeout(() => getConnectionStats(), 1000);
      }
    };
  }

  async function fetchIceServers() {
    // Get TURN server credentials dynamically using Metered.ca API
    let iceServers = [
      // STUN servers for NAT traversal (comment out for TURN-only testing)
      // { urls: "stun:stun.l.google.com:19302" },
      // { urls: "stun:stun1.l.google.com:19302" },
    ];

    // Try to get dynamic TURN servers from Metered.ca API
    try {
      const response = await fetch(
        "https://irisa.metered.live/api/v1/turn/credentials?apiKey=6437b90b4a436acebe12a1533600f6eb021f"
      );
      const dynamicIceServers = await response.json();

      // Use all servers from API (both STUN and TURN)
      iceServers = [...iceServers, ...dynamicIceServers];
    } catch (e) {
      log("âš ï¸ Failed to fetch dynamic TURN servers:", e.message);
      log("ðŸ”„ Falling back to static TURN servers");

      // Fallback to static TURN servers
      iceServers.push(
        {
          urls: "turn:openrelay.metered.ca:80",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:openrelay.metered.ca:443",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:openrelay.metered.ca:443?transport=tcp",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:relay1.expressturn.com:3480",
          username: "efPU52K4SLOQ34W2QY",
          credential: "1TJPNFxHKXrZfelz",
        }
      );
    }

    return iceServers;
  }

  async function connect() {
    const roomId = document.getElementById("room").value.trim();
    if (!roomId) return alert("enter room id");

    iceCandidates = [];
    activeCandidate = null;
    document.getElementById("connectionType").textContent = "â€”";
    document.getElementById("muteBtn").disabled = false;

    ws = new WebSocket(`${WS_URL}?roomId=${encodeURIComponent(roomId)}`);
    ws.onopen = () => log("[WebSocket] open");
    ws.onclose = (e) => log("[WebSocket] close", e.code, e.reason || "");
    ws.onerror = (e) => log("[WebSocket] error", e.message || e);
    ws.onmessage = async (ev) => {
      let msg;
      try {
        msg = JSON.parse(ev.data);
        log(
          `[received] ${msg.type}:`,
          JSON.stringify(msg).substring(0, 200) + "..."
        );
      } catch (e) {
        return log("drop non-JSON", ev.data, e);
      }

      if (msg.type === "role") {
        role = msg.role;
        log(`received role message: ${role}`);
        document.getElementById("role").textContent = role;
        return;
      }

      if (msg.type === "room" && msg.event === "peer-joined") {
        log(`peer joined â†’ room now has ${msg.peerCount} peers`);
        log(
          `Debug: role=${role}, signalingState=${pc?.signalingState}, haveLocalMedia=${haveLocalMedia}`
        );
        if (role === "host" && msg.peerCount > 1 && haveLocalMedia) {
          if (!pc || pc.connectionState === "closed") {
            log("Creating new WebRTC connection for rejoining peer");
            let iceServers = await fetchIceServers();
            pc = new RTCPeerConnection({
              iceServers: iceServers,
              iceCandidatePoolSize: 5,
            });

            localStream.getTracks().forEach((t) => {
              pc.addTrack(t, localStream);
            });

            setupWebRTCHandlers();
          }

          if (pc.signalingState === "stable") {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            log("sending [offer]");
            send({ type: "offer", sdp: offer.sdp });
          }
        }
        return;
      }

      if (msg.type === "offer") {
        await pc.setRemoteDescription({ type: "offer", sdp: msg.sdp });
        while (pendingIce.length) {
          await pc.addIceCandidate(pendingIce.shift());
        }
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        log("sending [answer]");
        send({ type: "answer", sdp: answer.sdp });
        return;
      }

      if (msg.type === "answer") {
        await pc.setRemoteDescription({ type: "answer", sdp: msg.sdp });
        while (pendingIce.length) {
          await pc.addIceCandidate(pendingIce.shift());
        }
        return;
      }

      if (msg.type === "ice") {
        const c = msg.candidate;
        if (pc.remoteDescription) {
          try {
            await pc.addIceCandidate(c);
          } catch (e) {
            log("addIceCandidate err", e);
          }
        } else {
          pendingIce.push(c);
        }
        return;
      }

      if (msg.type === "bye") {
        log("peer said bye â†’ closing");
        await cleanup("peer-bye");
        return;
      }

      if (msg.type === "peer-left") {
        log("peer left unexpectedly â†’ staying in room, ready for new peer");

        remoteEl.srcObject = null;
        if (pc) {
          pc.close();
          pc = null;
        }

        role = msg.newRole || "host";
        document.getElementById("role").textContent = role;
        pendingIce = [];
        iceCandidates = [];
        activeCandidate = null;
        document.getElementById("connectionType").textContent = "â€”";
        document.getElementById("activeCandidate").textContent = "â€”";
        document.getElementById("candidateCount").textContent = "0";
        log(
          `ðŸ”„ Ready for new peer to join (waiting for room.ready)... Role: ${role}`
        );
        return;
      }
    };

    let iceServers = await fetchIceServers();
    // log("ðŸ” Final iceServers being used:", JSON.stringify(iceServers, null, 2));
    pc = new RTCPeerConnection({
      iceServers: iceServers,
      iceCandidatePoolSize: 5, // Pre-gather ICE candidates for faster connection
    });

    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      haveLocalMedia = true;

      await refreshDevices();
    } catch (e) {
      log("getUserMedia failed:", e.message || e);
      return;
    }

    localEl.srcObject = localStream;
    localStream.getVideoTracks()[0].applyConstraints({ aspectRatio: 16 / 9 });
    localEl.play().catch(() => {});

    localStream.getTracks().forEach((t) => {
      pc.addTrack(t, localStream);
      log(`added track ${t.label} ${t.kind}`);
    });

    setupWebRTCHandlers();

    document.getElementById("deviceControls").style.display = "flex";
    document.getElementById("muteBtn").style.display = "inline-block";
    document.getElementById("videoToggleBtn").style.display = "inline-block";
  }

  async function bye() {
    await cleanup("self-bye");
  }

  function toggleMute() {
    if (!localStream) return;

    const audioTracks = localStream.getAudioTracks();
    if (audioTracks.length > 0) {
      isMuted = !isMuted;
      audioTracks[0].enabled = !isMuted; // false = muted, true = unmuted

      const muteBtn = document.getElementById("muteBtn");
      muteBtn.textContent = isMuted ? "Unmute Audio" : "Mute Audio";
      log(
        isMuted
          ? "Audio muted (local + remote)"
          : "Audio unmuted (local + remote)"
      );
    }
  }

  function toggleVideo() {
    if (!localStream) return;

    const videoTracks = localStream.getVideoTracks();
    if (videoTracks.length > 0) {
      isVideoEnabled = !isVideoEnabled;
      videoTracks[0].enabled = isVideoEnabled;

      const videoToggleBtn = document.getElementById("videoToggleBtn");
      if (videoToggleBtn) {
        videoToggleBtn.textContent = isVideoEnabled
          ? "Disable Video"
          : "Enable Video";
      }

      if (isVideoEnabled) {
        localEl.srcObject = localStream;
        localEl.play().catch(() => {});
      } else {
        localEl.srcObject = null;
      }

      log(
        isVideoEnabled
          ? "Video enabled (local + remote)"
          : "Video disabled (local + remote)"
      );
    }
  }

  async function cleanup(tag) {
    if (tag === "self-bye") {
      send({ type: "bye" });
      try {
        ws?.close();
      } catch {}
      ws = null;
    }

    try {
      pc?.close();
    } catch {}
    pc = null;

    remoteEl.srcObject = null;
    role = null;
    pendingIce = [];

    // Reset UI
    document.getElementById("role").textContent = "â€”";
    document.getElementById("muteBtn").disabled = true;
    document.getElementById("muteBtn").textContent = "Mute Audio";
    document.getElementById("muteBtn").style.display = "none";
    document.getElementById("videoToggleBtn").style.display = "none";
    document.getElementById("deviceControls").style.display = "none";
    isMuted = false;

    log("cleanup complete:", tag);
  }

  function send(obj) {
    const s = JSON.stringify(obj);
    ws?.send(s);
  }

  async function getConnectionStats() {
    try {
      const stats = await pc.getStats();
      let connectionType = "Unknown";
      let activeCandidateInfo = "Unknown";

      // First, collect all individual candidate reports
      const candidateReports = new Map();
      let totalCandidatesCount = 0;

      stats.forEach((report) => {
        if (
          report.type === "local-candidate" ||
          report.type === "remote-candidate"
        ) {
          candidateReports.set(report.id, report);
          totalCandidatesCount++;
        }
      });

      // Update total candidates count in UI
      document.getElementById("candidateCount").textContent =
        totalCandidatesCount;

      // Log all candidate reports to see what we have
      log(`ðŸ” Found ${totalCandidatesCount} individual candidate reports:`);
      candidateReports.forEach((candidate, id) => {
        log(
          `   ${id}: ${candidate.candidateType} ${candidate.address}:${candidate.port}`
        );
      });

      stats.forEach((report) => {
        if (report.type === "candidate-pair" && report.state === "succeeded") {
          log(`ðŸ” Found succeeded candidate pair: ${report.id}`);
          log(`   Local candidate ID: ${report.localCandidateId}`);
          log(`   Remote candidate ID: ${report.remoteCandidateId}`);

          // Look up the actual candidate objects from our map
          const localCandidate = candidateReports.get(report.localCandidateId);
          const remoteCandidate = candidateReports.get(
            report.remoteCandidateId
          );

          let localType = "unknown";
          let remoteType = "unknown";

          if (localCandidate) {
            localType = localCandidate.candidateType || "unknown";
            log(
              `   Local candidate: ${localType} ${localCandidate.address}:${localCandidate.port}`
            );
          } else {
            log(`   âŒ Local candidate not found: ${report.localCandidateId}`);
          }

          if (remoteCandidate) {
            remoteType = remoteCandidate.candidateType || "unknown";
            log(
              `   Remote candidate: ${remoteType} ${remoteCandidate.address}:${remoteCandidate.port}`
            );
          } else {
            log(
              `   âŒ Remote candidate not found: ${report.remoteCandidateId}`
            );
          }

          log(`âœ… Extracted - Local: ${localType}, Remote: ${remoteType}`);

          // Determine connection type based on the combination
          if (localType === "relay" || remoteType === "relay") {
            connectionType = "ðŸ”„ TURN Relay";
          } else if (localType === "host" && remoteType === "host") {
            connectionType = "ðŸ  Direct (Local)";
          } else if (
            localType === "srflx" ||
            remoteType === "srflx" ||
            localType === "prflx" ||
            remoteType === "prflx"
          ) {
            connectionType = "ðŸŒ STUN (Public IP)";
          } else {
            connectionType = "ðŸ”— Mixed Connection";
          }

          activeCandidateInfo = `${localType} â†” ${remoteType}`;
          activeCandidate = {
            local: localType,
            remote: remoteType,
            address: localCandidate?.address || "Unknown",
          };
        }
      });

      // Update UI
      document.getElementById("connectionType").textContent = connectionType;
      document.getElementById("activeCandidate").textContent =
        activeCandidateInfo;

      log(`ðŸ“Š Connection: ${connectionType} (${activeCandidateInfo})`);

      // Also update the global variables for other functions
      window.currentConnectionType = connectionType;
      window.currentActiveCandidate = activeCandidateInfo;
    } catch (e) {
      log("Failed to get connection stats:", e.message);
    }
  }

  async function refreshDevices() {
    try {
      await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      const devices = await navigator.mediaDevices.enumerateDevices();
      availableDevices = devices;

      const videoDevices = devices.filter(
        (device) => device.kind === "videoinput"
      );
      const videoSelect = document.getElementById("videoSelect");

      videoDevices.forEach((device, index) => {
        const option = document.createElement("option");
        option.value = device.deviceId;
        option.text = device.label || `Camera ${index + 1}`;
        videoSelect.appendChild(option);
      });

      const audioDevices = devices.filter(
        (device) => device.kind === "audioinput"
      );
      const audioSelect = document.getElementById("audioSelect");
      audioSelect.innerHTML = "";

      audioDevices.forEach((device, index) => {
        const option = document.createElement("option");
        option.value = device.deviceId;
        option.text = device.label || `Microphone ${index + 1}`;
        audioSelect.appendChild(option);
      });

      log(
        `ðŸ“± Found ${videoDevices.length} cameras and ${audioDevices.length} microphones`
      );
    } catch (error) {
      log("âŒ Failed to refresh devices:", error.message);
    }
  }

  async function replaceTrack(oldTrack, newTrack, trackKind) {
    if (oldTrack) {
      localStream.removeTrack(oldTrack);
      oldTrack.stop();
    }

    if (newTrack) {
      localStream.addTrack(newTrack);
    }

    if (pc) {
      const sender = pc
        .getSenders()
        .find((s) => s.track && s.track.kind === trackKind);
      if (sender) {
        await sender.replaceTrack(newTrack);
      }
    }
  }

  async function changeVideoInput() {
    const videoSelect = document.getElementById("videoSelect");
    const selectedDeviceId = videoSelect.value;

    if (!localStream || !selectedDeviceId) return;

    try {
      const oldVideoTrack = localStream.getVideoTracks()[0];
      const newStream = await navigator.mediaDevices.getUserMedia({
        video: { deviceId: { exact: selectedDeviceId } },
        audio: false,
      });
      const newVideoTrack = newStream.getVideoTracks()[0];

      await replaceTrack(oldVideoTrack, newVideoTrack, "video");
      newVideoTrack.applyConstraints({ aspectRatio: 16 / 9 });

      log(
        `ðŸ“¹ Switched to camera: ${videoSelect.options[videoSelect.selectedIndex].text}`
      );
    } catch (error) {
      log("âŒ Failed to change video input:", error.message);
    }
  }

  async function changeAudioInput() {
    const audioSelect = document.getElementById("audioSelect");
    const selectedDeviceId = audioSelect.value;

    if (!localStream || !selectedDeviceId) return;

    try {
      const oldAudioTrack = localStream.getAudioTracks()[0];
      const newStream = await navigator.mediaDevices.getUserMedia({
        video: false,
        audio: { deviceId: { exact: selectedDeviceId } },
      });
      const newAudioTrack = newStream.getAudioTracks()[0];

      await replaceTrack(oldAudioTrack, newAudioTrack, "audio");

      log(
        `ðŸŽ¤ Switched to microphone: ${audioSelect.options[audioSelect.selectedIndex].text}`
      );
    } catch (error) {
      log("âŒ Failed to change audio input:", error.message);
    }
  }

  const log = (...a) => {
    const el = document.getElementById("log");
    el.textContent += a.join(" ") + "\n";
    el.scrollTop = el.scrollHeight;
  };
</script>
