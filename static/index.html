<!doctype html>
<meta charset="utf-8" />
<title>Irisa â€“ P2P WebRTC video chat app</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    padding: 16px;
  }
  video {
    width: 48%;
    background: #d5d5d5;
    aspect-ratio: 16/9;
  }
  .row {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
  }
  #log {
    white-space: pre-wrap;
    background: #0b1020;
    color: #d6e4ff;
    padding: 8px;
    border-radius: 8px;
    max-height: 40vh;
    overflow: auto;
  }
  select {
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    margin: 0 4px;
  }
  label {
    font-weight: 500;
    margin-right: 8px;
  }
</style>

<h2>Irisa â€“ P2P WebRTC video chat app</h2>
<div class="row">
  <input id="room" value="abc" />
  <button onclick="connect()">Connect</button>
  <button onclick="bye()">Bye</button>
  <button id="muteBtn" onclick="toggleMute()" disabled style="display: none">
    Mute Audio
  </button>
  <button id="videoToggleBtn" onclick="toggleVideo()" style="display: none">
    Disable Video
  </button>
  <span>Role: <b id="role">â€”</b></span>
  <span>Peer ID: <b id="peerId">â€”</b></span>
</div>

<div class="row" id="deviceControls" style="display: none">
  <label>Camera:</label>
  <select id="videoSelect" onchange="changeVideoInput()"></select>
  <label>Microphone:</label>
  <select id="audioSelect" onchange="changeAudioInput()"></select>
</div>

<div class="row">
  <video id="local" playsinline muted></video>
  <div id="remoteVideos"></div>
</div>

<div id="iceInfo">
  <div>
    <strong>Connection Type:</strong> <span id="connectionType">â€”</span>
  </div>
</div>

<h3>Log</h3>
<pre id="log"></pre>

<script>
  const WS_URL =
    (location.protocol === "https:" ? "wss://" : "ws://") +
    location.host +
    "/ws";
  let ws,
    pcs = new Map(),
    localStream,
    role = null,
    myPeerId = null;
  let haveLocalMedia = false;
  let pendingIce = [];
  let isMuted = false;
  let iceCandidates = [];
  let activeCandidate = null;
  let availableDevices = [];
  let isVideoEnabled = true;

  const localEl = document.getElementById("local");
  const remoteEl = document.getElementById("remote");

  async function connect() {
    const roomId = document.getElementById("room").value.trim();
    if (!roomId) return alert("enter room id");

    iceCandidates = [];
    activeCandidate = null;
    document.getElementById("connectionType").textContent = "â€”";
    document.getElementById("muteBtn").disabled = false;

    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      haveLocalMedia = true;

      await refreshDevices();
    } catch (e) {
      return;
    }

    localEl.srcObject = localStream;
    localStream.getVideoTracks()[0].applyConstraints({ aspectRatio: 16 / 9 });
    localEl.play().catch(() => {});

    document.getElementById("deviceControls").style.display = "flex";
    document.getElementById("muteBtn").style.display = "inline-block";
    document.getElementById("videoToggleBtn").style.display = "inline-block";

    ws = new WebSocket(`${WS_URL}?roomId=${encodeURIComponent(roomId)}`);
    ws.onopen = () => log("[WebSocket] open");
    ws.onclose = (e) => log("[WebSocket] close", e.code, e.reason || "");
    ws.onerror = (e) => log("[WebSocket] error", e.message || e);
    ws.onmessage = async (ev) => {
      let msg;
      try {
        msg = JSON.parse(ev.data);
      } catch (e) {}

      if (msg.type === "role") {
        role = msg.role;
        myPeerId = msg.peerId;
        document.getElementById("role").textContent = role;
        document.getElementById("peerId").textContent = myPeerId;
      }

      if (msg.type === "room" && msg.event === "peer-joined") {
        const newPeerId = msg.peerId;

        if (newPeerId !== myPeerId && haveLocalMedia && !pcs.has(newPeerId)) {
          await createPeerConnection(newPeerId);
          await sendOffer(newPeerId);
        }
        return;
      }

      if (msg.type === "offer") {
        const existingPeerId = msg.fromPeer;
        log(`received [offer] from peer ${existingPeerId}`);

        if (!pcs.has(existingPeerId)) {
          await createPeerConnection(existingPeerId);
          await sendAnswer(existingPeerId, msg.sdp);
        }
        return;
      }

      if (msg.type === "answer") {
        const existingPeerId = msg.fromPeer;
        log(`received [answer] from peer ${existingPeerId}`);

        // Get peer connection for this peer
        const targetPc = pcs.get(existingPeerId);
        if (targetPc) {
          await targetPc.setRemoteDescription({ type: "answer", sdp: msg.sdp });
          while (pendingIce.length) {
            await targetPc.addIceCandidate(pendingIce.shift());
          }
        }
        return;
      }

      if (msg.type === "ice") {
        const c = msg.candidate;
        const existingPeerId = msg.fromPeer;

        // Get peer connection for this peer
        const targetPc = pcs.get(existingPeerId);
        if (targetPc) {
          if (targetPc.remoteDescription) {
            try {
              await targetPc.addIceCandidate(c);
            } catch (e) {}
          } else {
            pendingIce.push(c);
          }
        } else {
          pendingIce.push(c);
        }
        return;
      }

      if (msg.type === "bye") {
        log("peer said bye â†’ closing");
        await cleanup("peer-bye");
        return;
      }

      if (msg.type === "peer-left") {
        const leftPeerId = msg.peerId;
        log(
          `peer ${leftPeerId} left unexpectedly â†’ staying in room, ready for new peer`
        );

        // Close the specific peer connection and remove its video
        const leftPc = pcs.get(leftPeerId);
        if (leftPc) {
          leftPc.close();
          pcs.delete(leftPeerId);
          log(`Closed connection to peer ${leftPeerId}`);
        }

        // Remove the remote video container for this peer
        const videoContainer = document.getElementById(
          `container-${leftPeerId}`
        );
        if (videoContainer) {
          videoContainer.remove();
        }

        role = msg.newRole || "host";
        document.getElementById("role").textContent = role;
        pendingIce = [];
        iceCandidates = [];
        activeCandidate = null;
        document.getElementById("connectionType").textContent = "â€”";
        log(
          `ðŸ”„ Ready for new peer to join (waiting for room.ready)... Role: ${role}`
        );
        return;
      }
    };
  }

  async function createPeerConnection(peerId) {
    // Check if PC already exists
    if (pcs.has(peerId)) {
      log(`âŒ PC already exists for peer ${peerId}`);
      return pcs.get(peerId);
    }

    log(`[RTCPeerConnection] creating new PC for peer ${peerId}`);
    let iceServers = await fetchIceServers();
    const pc = new RTCPeerConnection({
      iceServers: iceServers,
      iceCandidatePoolSize: 5,
    });

    localStream.getTracks().forEach((t) => {
      pc.addTrack(t, localStream);
    });

    setupWebRTCHandlers(pc, peerId);
    pcs.set(peerId, pc);

    return pc;
  }

  async function sendOffer(peerId) {
    const pc = pcs.get(peerId);
    if (!pc) return;

    if (pc.signalingState === "stable") {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      log(`sending [offer] to peer ${peerId}`);
      send({
        type: "offer",
        sdp: offer.sdp,
        targetPeer: peerId,
        fromPeer: myPeerId,
      });
    }
  }

  async function sendAnswer(peerId, offerSdp) {
    const pc = pcs.get(peerId);
    if (!pc) return;

    await pc.setRemoteDescription({ type: "offer", sdp: offerSdp });
    while (pendingIce.length) {
      await pc.addIceCandidate(pendingIce.shift());
    }
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    log(`sending [answer] to peer ${peerId}`);
    send({
      type: "answer",
      sdp: answer.sdp,
      targetPeer: peerId,
      fromPeer: myPeerId,
    });
  }

  function setupWebRTCHandlers(pc, peerId) {
    pc.ontrack = async (e) => {
      const stream = e.streams[0];
      if (stream) {
        let remoteVideo = document.getElementById(`remote-${peerId}`);

        if (!remoteVideo) {
          // Create video container with peer ID label
          const videoContainer = document.createElement("div");
          videoContainer.id = `container-${peerId}`;
          videoContainer.style.position = "relative";
          videoContainer.style.width = "70%";
          videoContainer.style.display = "inline-block";
          videoContainer.style.margin = "4px";

          // Create peer ID label
          const peerLabel = document.createElement("div");
          peerLabel.textContent = `Peer: ${peerId.substring(0, 8)}...`;
          peerLabel.style.position = "absolute";
          peerLabel.style.top = "4px";
          peerLabel.style.left = "4px";
          peerLabel.style.background = "rgba(0, 0, 0, 0.7)";
          peerLabel.style.color = "white";
          peerLabel.style.padding = "2px 6px";
          peerLabel.style.borderRadius = "4px";
          peerLabel.style.fontSize = "12px";
          peerLabel.style.fontFamily = "monospace";
          peerLabel.style.zIndex = "10";

          // Create video element
          remoteVideo = document.createElement("video");
          remoteVideo.id = `remote-${peerId}`;
          remoteVideo.playsInline = true;
          remoteVideo.style.width = "100%";
          remoteVideo.style.background = "#d5d5d5";
          remoteVideo.style.aspectRatio = "16/9";
          remoteVideo.style.borderRadius = "8px";

          // Add label and video to container
          videoContainer.appendChild(peerLabel);
          videoContainer.appendChild(remoteVideo);

          const remoteVideosContainer = document.getElementById("remoteVideos");
          remoteVideosContainer.appendChild(videoContainer);
        } else {
        }

        // Always assign or re-assign srcObject to the stream
        // The MediaStream object itself will update as tracks are added/removed
        remoteVideo.srcObject = stream;

        try {
          await remoteVideo.play();
        } catch (err) {}
      } else {
      }
    };

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        iceCandidates.push({
          type: e.candidate.type,
          protocol: e.candidate.protocol,
          address: e.candidate.address,
          port: e.candidate.port,
          candidateType: e.candidate.candidateType || e.candidate.type,
        });
        send({
          type: "ice",
          candidate: e.candidate,
          targetPeer: peerId,
          fromPeer: myPeerId,
        });
      }
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === "connected") {
        log("âœ… Two-way communication established!");

        // Log the current pcs Map contents
        log(`ðŸ“Š Current pcs Map (${pcs.size} connections):`);
        for (const [peerId, pc] of pcs) {
          log(
            `  - Peer ${peerId}: ${pc.connectionState} (signaling: ${pc.signalingState})`
          );
        }
      }
    };
  }

  async function fetchIceServers() {
    // Get TURN server credentials dynamically using Metered.ca API
    let iceServers = [
      // STUN servers for NAT traversal (comment out for TURN-only testing)
      // { urls: "stun:stun.l.google.com:19302" },
      // { urls: "stun:stun1.l.google.com:19302" },
    ];

    // Try to get dynamic TURN servers from Metered.ca API
    try {
      const response = await fetch(
        "https://irisa.metered.live/api/v1/turn/credentials?apiKey=6437b90b4a436acebe12a1533600f6eb021f"
      );
      const dynamicIceServers = await response.json();

      // Use all servers from API (both STUN and TURN)
      iceServers = [...iceServers, ...dynamicIceServers];
    } catch (e) {
      // Fallback to static TURN servers
      iceServers.push(
        {
          urls: "turn:openrelay.metered.ca:80",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:openrelay.metered.ca:443",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:openrelay.metered.ca:443?transport=tcp",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:relay1.expressturn.com:3480",
          username: "efPU52K4SLOQ34W2QY",
          credential: "1TJPNFxHKXrZfelz",
        }
      );
    }

    return iceServers;
  }

  async function bye() {
    await cleanup("self-bye");
  }

  function toggleMute() {
    if (!localStream) return;

    const audioTracks = localStream.getAudioTracks();
    if (audioTracks.length > 0) {
      isMuted = !isMuted;
      audioTracks[0].enabled = !isMuted; // false = muted, true = unmuted

      const muteBtn = document.getElementById("muteBtn");
      muteBtn.textContent = isMuted ? "Unmute Audio" : "Mute Audio";
    }
  }

  function toggleVideo() {
    if (!localStream) return;

    const videoTracks = localStream.getVideoTracks();
    if (videoTracks.length > 0) {
      isVideoEnabled = !isVideoEnabled;
      videoTracks[0].enabled = isVideoEnabled;

      const videoToggleBtn = document.getElementById("videoToggleBtn");
      if (videoToggleBtn) {
        videoToggleBtn.textContent = isVideoEnabled
          ? "Disable Video"
          : "Enable Video";
      }

      if (isVideoEnabled) {
        localEl.srcObject = localStream;
        localEl.play().catch(() => {});
      } else {
        localEl.srcObject = null;
      }
    }
  }

  async function cleanup(tag) {
    if (tag === "self-bye") {
      send({ type: "bye" });
      try {
        ws?.close();
      } catch {}
      ws = null;

      // Reset UI
      document.getElementById("role").textContent = "â€”";
      document.getElementById("peerId").textContent = "â€”";
      document.getElementById("muteBtn").disabled = true;
      document.getElementById("muteBtn").textContent = "Mute Audio";
      document.getElementById("muteBtn").style.display = "none";
      document.getElementById("videoToggleBtn").style.display = "none";
      document.getElementById("deviceControls").style.display = "none";
      isMuted = false;

      // Close all peer connections
      for (const [peerId, pc] of pcs) {
        try {
          pc.close();
        } catch {}
      }
      pcs.clear();

      // Clear all remote videos
      const remoteVideosContainer = document.getElementById("remoteVideos");
      remoteVideosContainer.innerHTML = "";
      role = null;
      myPeerId = null;
      pendingIce = [];
    }
  }

  function send(obj) {
    const s = JSON.stringify(obj);
    ws?.send(s);
  }

  async function refreshDevices() {
    try {
      await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      const devices = await navigator.mediaDevices.enumerateDevices();
      availableDevices = devices;

      const videoDevices = devices.filter(
        (device) => device.kind === "videoinput"
      );
      const videoSelect = document.getElementById("videoSelect");

      videoDevices.forEach((device, index) => {
        const option = document.createElement("option");
        option.value = device.deviceId;
        option.text = device.label || `Camera ${index + 1}`;
        videoSelect.appendChild(option);
      });

      const audioDevices = devices.filter(
        (device) => device.kind === "audioinput"
      );
      const audioSelect = document.getElementById("audioSelect");
      audioSelect.innerHTML = "";

      audioDevices.forEach((device, index) => {
        const option = document.createElement("option");
        option.value = device.deviceId;
        option.text = device.label || `Microphone ${index + 1}`;
        audioSelect.appendChild(option);
      });
    } catch (error) {}
  }

  async function replaceTrack(oldTrack, newTrack, trackKind) {
    if (oldTrack) {
      localStream.removeTrack(oldTrack);
      oldTrack.stop();
    }

    if (newTrack) {
      localStream.addTrack(newTrack);
    }

    // Update all peer connections
    for (const [peerId, pc] of pcs) {
      const sender = pc
        .getSenders()
        .find((s) => s.track && s.track.kind === trackKind);
      if (sender) {
        await sender.replaceTrack(newTrack);
        // log(`Updated ${trackKind} track for peer ${peerId}`);
      }
    }
  }

  async function changeVideoInput() {
    const videoSelect = document.getElementById("videoSelect");
    const selectedDeviceId = videoSelect.value;

    if (!localStream || !selectedDeviceId) return;

    try {
      const oldVideoTrack = localStream.getVideoTracks()[0];
      const newStream = await navigator.mediaDevices.getUserMedia({
        video: { deviceId: { exact: selectedDeviceId } },
        audio: false,
      });
      const newVideoTrack = newStream.getVideoTracks()[0];

      await replaceTrack(oldVideoTrack, newVideoTrack, "video");
      newVideoTrack.applyConstraints({ aspectRatio: 16 / 9 });
    } catch (error) {}
  }

  async function changeAudioInput() {
    const audioSelect = document.getElementById("audioSelect");
    const selectedDeviceId = audioSelect.value;

    if (!localStream || !selectedDeviceId) return;

    try {
      const oldAudioTrack = localStream.getAudioTracks()[0];
      const newStream = await navigator.mediaDevices.getUserMedia({
        video: false,
        audio: { deviceId: { exact: selectedDeviceId } },
      });
      const newAudioTrack = newStream.getAudioTracks()[0];

      await replaceTrack(oldAudioTrack, newAudioTrack, "audio");
    } catch (error) {}
  }

  const log = (...a) => {
    const el = document.getElementById("log");
    el.textContent += a.join(" ") + "\n";
    el.scrollTop = el.scrollHeight;
  };
</script>
