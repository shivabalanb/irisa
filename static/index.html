<!doctype html>
<meta charset="utf-8" />
<title>Irisa â€“ P2P WebRTC video chat app</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    font-size: 12px;
    padding: 16px;
  }
  video {
    background: #d5d5d5;
    aspect-ratio: 16/9;
  }
  .video-box {
    width: 400px;
    border-radius: 8px;
  }
  #local {
    transform: scaleX(-1); /* Mirror the local video for self-view */
  }

  .row {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
  }
  #log {
    white-space: pre-wrap;
    background: #0b1020;
    color: #d6e4ff;
    padding: 8px;
    border-radius: 8px;
    max-height: 40vh;
    overflow: auto;
  }
  select {
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    margin: 0 4px;
  }
  label {
    font-weight: 500;
    margin-right: 8px;
  }
</style>

<h2>Irisa â€“ P2P WebRTC video chat app</h2>
<div class="row">
  <input id="room" value="abc" />
  <button onclick="connect()">Connect</button>
  <button id="muteBtn" onclick="toggleMute()" disabled style="display: none">
    Mute Audio
  </button>
  <button id="videoToggleBtn" onclick="toggleVideo()" style="display: none">
    Disable Video
  </button>
  <span>Peer ID: <b id="peerId">â€”</b></span>
</div>

<div class="row" id="deviceControls" style="display: none">
  <label>Camera:</label>
  <select id="videoSelect" onchange="changeVideoInput()"></select>
  <label>Microphone:</label>
  <select id="audioSelect" onchange="changeAudioInput()"></select>
  <button onclick="refreshDevices()">Refresh Devices</button>
</div>

<div class="row">
  <video id="local" class="video-box" playsinline muted></video>
  <div id="remoteVideos"></div>
</div>

<h3>Log</h3>
<pre id="log"></pre>

<script>
  const WS_URL =
    (location.protocol === "https:" ? "wss://" : "ws://") +
    location.host +
    "/ws";
  let ws,
    pcs = new Map(),
    localStream,
    myPeerId = null;
  let haveLocalMedia = false;
  let pendingIce = new Map(); // peerId -> RTCIceCandidateInit[]
  let isMuted = false;
  let availableDevices = [];
  let isVideoEnabled = true;

  const localEl = document.getElementById("local");
  const remoteEl = document.getElementById("remote");

  async function connect() {
    const roomId = document.getElementById("room").value.trim();
    if (!roomId) return alert("enter room id");

    document.getElementById("muteBtn").disabled = false;

    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      haveLocalMedia = true;

      await refreshDevices();
    } catch (e) {
      return;
    }

    localEl.srcObject = localStream;
    localStream.getVideoTracks()[0].applyConstraints({ aspectRatio: 16 / 9 });
    localEl.play().catch(() => {});

    document.getElementById("deviceControls").style.display = "flex";
    document.getElementById("muteBtn").style.display = "inline-block";
    document.getElementById("videoToggleBtn").style.display = "inline-block";

    ws = new WebSocket(`${WS_URL}?roomId=${encodeURIComponent(roomId)}`);
    ws.onmessage = async (ev) => {
      const msg = JSON.parse(ev.data);

      switch (msg.type) {
        case "peer-joined":
          await handlePeerJoined(msg);
          break;
        case "offer":
          await handleOffer(msg);
          break;
        case "answer":
          await handleAnswer(msg);
          break;
        case "ice":
          await handleIce(msg);
          break;
      }
    };
  }

  async function handleIce(msg) {
    const c = msg.candidate;
    const existingPeerId = msg.fromPeer;

    // Get peer connection for this peer
    const targetPc = pcs.get(existingPeerId);
    if (targetPc) {
      if (targetPc.remoteDescription) {
        try {
          await targetPc.addIceCandidate(c);
        } catch (e) {}
      } else {
        const queue = pendingIce.get(existingPeerId) || [];
        queue.push(c);
        pendingIce.set(existingPeerId, queue);
      }
    } else {
      const queue = pendingIce.get(existingPeerId) || [];
      queue.push(c);
      pendingIce.set(existingPeerId, queue);
    }
  }

  async function handleAnswer(msg) {
    const existingPeerId = msg.fromPeer;
    log(`[answer] from peer ${existingPeerId}`);

    // Get peer connection for this peer
    const targetPc = pcs.get(existingPeerId);
    if (targetPc) {
      await targetPc.setRemoteDescription({ type: "answer", sdp: msg.sdp });
      const queue = pendingIce.get(existingPeerId) || [];
      while (queue.length) {
        try {
          await targetPc.addIceCandidate(queue.shift());
        } catch (e) {}
      }
      pendingIce.set(existingPeerId, queue);
    }
  }

  async function handleOffer(msg) {
    const existingPeerId = msg.fromPeer;

    if (!pcs.has(existingPeerId)) {
      log(`[offer] from peer ${existingPeerId}`);
      await createPeerConnection(existingPeerId);
      await sendAnswer(existingPeerId, msg.sdp);
    }
  }

  async function handlePeerJoined(msg) {
    const peerId = msg.peerId;
    log(`[peer-joined] from peer ${peerId}`);

    // If this is about me, set my peerId
    if (!myPeerId) {
      myPeerId = peerId;
      document.getElementById("peerId").textContent = myPeerId;
    }

    // If this is about someone else and I have media, connect to them
    if (peerId !== myPeerId && haveLocalMedia && !pcs.has(peerId)) {
      await createPeerConnection(peerId);
      await sendOffer(peerId);
    }
  }

  async function createPeerConnection(peerId) {
    // Check if PC already exists
    if (pcs.has(peerId)) {
      log(`âŒ PC already exists for peer ${peerId}`);
      return pcs.get(peerId);
    }

    log(`[RTCPeerConnection] creating new PC for peer ${peerId}`);
    let iceServers = await fetchIceServers();
    const pc = new RTCPeerConnection({
      iceServers: iceServers,
      iceCandidatePoolSize: 5,
    });

    localStream.getTracks().forEach((t) => {
      pc.addTrack(t, localStream);
    });

    setupWebRTCHandlers(pc, peerId);
    pcs.set(peerId, pc);

    return pc;
  }

  async function sendOffer(peerId) {
    const pc = pcs.get(peerId);
    if (!pc) return;

    if (pc.signalingState === "stable") {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      send({
        type: "offer",
        sdp: offer.sdp,
        targetPeer: peerId,
        fromPeer: myPeerId,
      });
    }
  }

  async function sendAnswer(peerId, offerSdp) {
    const pc = pcs.get(peerId);
    if (!pc) return;

    await pc.setRemoteDescription({ type: "offer", sdp: offerSdp });
    const queue = pendingIce.get(peerId) || [];
    while (queue.length) {
      try {
        await pc.addIceCandidate(queue.shift());
      } catch (e) {}
    }
    pendingIce.set(peerId, queue);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    send({
      type: "answer",
      sdp: answer.sdp,
      targetPeer: peerId,
      fromPeer: myPeerId,
    });
  }

  function setupWebRTCHandlers(pc, peerId) {
    pc.ontrack = async (e) => {
      const stream = e.streams[0];
      if (stream) {
        let remoteVideo = document.getElementById(`remote-${peerId}`);

        if (!remoteVideo) {
          // Create video container with peer ID label
          const videoContainer = document.createElement("div");
          videoContainer.id = `container-${peerId}`;
          videoContainer.style.position = "relative";
          videoContainer.style.margin = "4px";

          // Create peer ID label
          const peerLabel = document.createElement("div");
          peerLabel.textContent = `Peer: ${peerId.substring(0, 8)}...`;
          peerLabel.style.position = "absolute";
          peerLabel.style.top = "4px";
          peerLabel.style.left = "4px";
          peerLabel.style.background = "rgba(0, 0, 0, 0.7)";
          peerLabel.style.color = "white";
          peerLabel.style.padding = "2px 6px";
          peerLabel.style.borderRadius = "4px";
          peerLabel.style.fontSize = "12px";
          peerLabel.style.fontFamily = "monospace";
          peerLabel.style.zIndex = "10";

          // Create video element
          remoteVideo = document.createElement("video");
          remoteVideo.id = `remote-${peerId}`;
          remoteVideo.playsInline = true;
          remoteVideo.className = "video-box";

          // Create volume control
          const volumeControl = document.createElement("div");
          volumeControl.style.position = "absolute";
          volumeControl.style.bottom = "8px";
          volumeControl.style.left = "8px";
          volumeControl.style.right = "8px";
          volumeControl.style.background = "rgba(0, 0, 0, 0.7)";
          volumeControl.style.borderRadius = "4px";
          volumeControl.style.padding = "4px";
          volumeControl.style.display = "none"; // Hidden by default
          volumeControl.style.alignItems = "center";
          volumeControl.style.gap = "8px";

          const volumeLabel = document.createElement("span");
          volumeLabel.textContent = "ðŸ”Š";
          volumeLabel.style.color = "white";
          volumeLabel.style.fontSize = "12px";

          const volumeSlider = document.createElement("input");
          volumeSlider.type = "range";
          volumeSlider.min = "0";
          volumeSlider.max = "100";
          volumeSlider.value = "100";
          volumeSlider.style.flex = "1";
          volumeSlider.style.height = "4px";
          volumeSlider.oninput = (e) => {
            remoteVideo.volume = e.target.value / 100;
          };

          volumeControl.appendChild(volumeLabel);
          volumeControl.appendChild(volumeSlider);

          // Add click event to toggle volume controls
          videoContainer.onclick = () => {
            const isVisible = volumeControl.style.display !== "none";
            volumeControl.style.display = isVisible ? "none" : "flex";
          };

          // Add label, video, and volume control to container
          videoContainer.appendChild(peerLabel);
          videoContainer.appendChild(remoteVideo);
          videoContainer.appendChild(volumeControl);

          const remoteVideosContainer = document.getElementById("remoteVideos");
          remoteVideosContainer.appendChild(videoContainer);
        } else {
        }

        remoteVideo.srcObject = stream;

        try {
          await remoteVideo.play();
        } catch (err) {}
      } else {
      }
    };

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        send({
          type: "ice",
          candidate: e.candidate,
          targetPeer: peerId,
          fromPeer: myPeerId,
        });
      }
    };

    pc.onconnectionstatechange = () => {
      if (pc.connectionState === "connected") {
        log("âœ… Two-way communication established!");

        // Log the current pcs Map contents
        log(`Current pcs Map (${pcs.size} connections):`);
        for (const [peerId, pc] of pcs) {
          log(`  - Peer ${peerId}: ${pc.connectionState} ${pc.signalingState}`);
        }
      } else if (
        pc.connectionState === "disconnected" ||
        pc.connectionState === "failed" ||
        pc.connectionState === "closed"
      ) {
        log(pc.connectionState);
        log(`âŒ Peer ${peerId} disconnected (${pc.connectionState})`);

        // Clean up the peer connection
        pc.close();
        pcs.delete(peerId);

        // Remove the remote video
        const videoContainer = document.getElementById(`container-${peerId}`);
        if (videoContainer) {
          videoContainer.remove();
        }

        // Clean up pending ICE for this peer
        pendingIce.delete(peerId);
      }
    };
  }

  async function fetchIceServers() {
    // Get TURN server credentials dynamically using Metered.ca API
    let iceServers = [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:stun1.l.google.com:19302" },
      {
        urls: "turn:openrelay.metered.ca:80",
        username: "openrelayproject",
        credential: "openrelayproject",
      },
      {
        urls: "turn:openrelay.metered.ca:443",
        username: "openrelayproject",
        credential: "openrelayproject",
      },
      {
        urls: "turn:openrelay.metered.ca:443?transport=tcp",
        username: "openrelayproject",
        credential: "openrelayproject",
      },
      {
        urls: "turn:relay1.expressturn.com:3480",
        username: "efPU52K4SLOQ34W2QY",
        credential: "1TJPNFxHKXrZfelz",
      },
    ];

    // Try to get dynamic TURN servers from Metered.ca API
    const response = await fetch(
      "https://irisa.metered.live/api/v1/turn/credentials?apiKey=6437b90b4a436acebe12a1533600f6eb021f"
    );
    const dynamicIceServers = await response.json();

    // Use all servers from API (both STUN and TURN)
    iceServers = [...iceServers, ...dynamicIceServers];

    return iceServers;
  }

  function toggleMute() {
    if (!localStream) return;

    const audioTracks = localStream.getAudioTracks();
    if (audioTracks.length > 0) {
      isMuted = !isMuted;
      audioTracks[0].enabled = !isMuted; // false = muted, true = unmuted

      const muteBtn = document.getElementById("muteBtn");
      muteBtn.textContent = isMuted ? "Unmute Audio" : "Mute Audio";
    }
  }

  function toggleVideo() {
    if (!localStream) return;

    const videoTracks = localStream.getVideoTracks();
    if (videoTracks.length > 0) {
      isVideoEnabled = !isVideoEnabled;
      videoTracks[0].enabled = isVideoEnabled;

      const videoToggleBtn = document.getElementById("videoToggleBtn");
      if (videoToggleBtn) {
        videoToggleBtn.textContent = isVideoEnabled
          ? "Disable Video"
          : "Enable Video";
      }

      if (isVideoEnabled) {
        localEl.srcObject = localStream;
        localEl.play().catch(() => {});
      } else {
        localEl.srcObject = null;
      }
    }
  }

  async function cleanup(tag) {
    if (tag === "self-bye") {
      try {
        ws?.close();
      } catch {}
      ws = null;

      // Reset UI
      document.getElementById("peerId").textContent = "â€”";
      document.getElementById("muteBtn").disabled = true;
      document.getElementById("muteBtn").textContent = "Mute Audio";
      document.getElementById("muteBtn").style.display = "none";
      document.getElementById("videoToggleBtn").style.display = "none";
      document.getElementById("deviceControls").style.display = "none";
      isMuted = false;

      // Close all peer connections
      for (const [peerId, pc] of pcs) {
        try {
          pc.close();
        } catch {}
      }
      pcs.clear();

      // Clear all remote videos
      const remoteVideosContainer = document.getElementById("remoteVideos");
      remoteVideosContainer.innerHTML = "";
      myPeerId = null;
      pendingIce.delete(leftPeerId);
      pendingIce = new Map();
    }
  }

  function send(obj) {
    const s = JSON.stringify(obj);
    ws?.send(s);
  }

  async function refreshDevices() {
    try {
      await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      const devices = await navigator.mediaDevices.enumerateDevices();
      availableDevices = devices;

      const videoDevices = devices.filter(
        (device) =>
          device.kind === "videoinput" && !device.label?.includes("Virtual")
      );
      const videoSelect = document.getElementById("videoSelect");
      videoSelect.innerHTML = "";

      videoDevices.forEach((device, index) => {
        const option = document.createElement("option");
        option.value = device.deviceId;
        option.text = device.label || `Camera ${index + 1}`;
        videoSelect.appendChild(option);
      });

      const audioDevices = devices.filter(
        (device) =>
          device.kind === "audioinput" && !device.label?.includes("Virtual")
      );

      const audioSelect = document.getElementById("audioSelect");
      audioSelect.innerHTML = "";

      audioDevices.forEach((device, index) => {
        const option = document.createElement("option");
        option.value = device.deviceId;
        option.text = device.label || `Microphone ${index + 1}`;
        audioSelect.appendChild(option);
      });
    } catch (error) {}
  }

  async function replaceTrack(oldTrack, newTrack, trackKind) {
    if (oldTrack) {
      localStream.removeTrack(oldTrack);
      oldTrack.stop();
    }

    if (newTrack) {
      localStream.addTrack(newTrack);
    }

    // Update all peer connections
    for (const [peerId, pc] of pcs) {
      const sender = pc
        .getSenders()
        .find((s) => s.track && s.track.kind === trackKind);
      if (sender) {
        await sender.replaceTrack(newTrack);
        // log(`Updated ${trackKind} track for peer ${peerId}`);
      }
    }
  }

  async function changeVideoInput() {
    const videoSelect = document.getElementById("videoSelect");
    const selectedDeviceId = videoSelect.value;

    if (!localStream || !selectedDeviceId) return;

    try {
      const oldVideoTrack = localStream.getVideoTracks()[0];
      const newStream = await navigator.mediaDevices.getUserMedia({
        video: { deviceId: { exact: selectedDeviceId } },
        audio: false,
      });
      const newVideoTrack = newStream.getVideoTracks()[0];

      await replaceTrack(oldVideoTrack, newVideoTrack, "video");
      newVideoTrack.applyConstraints({ aspectRatio: 16 / 9 });
    } catch (error) {}
  }

  async function changeAudioInput() {
    const audioSelect = document.getElementById("audioSelect");
    const selectedDeviceId = audioSelect.value;

    if (!localStream || !selectedDeviceId) return;

    try {
      const oldAudioTrack = localStream.getAudioTracks()[0];
      const newStream = await navigator.mediaDevices.getUserMedia({
        video: false,
        audio: { deviceId: { exact: selectedDeviceId } },
      });
      const newAudioTrack = newStream.getAudioTracks()[0];

      await replaceTrack(oldAudioTrack, newAudioTrack, "audio");
    } catch (error) {}
  }

  const log = (...a) => {
    const el = document.getElementById("log");
    el.textContent += a.join(" ") + "\n";
    el.scrollTop = el.scrollHeight;
  };
</script>
