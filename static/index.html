<!doctype html>
<meta charset="utf-8" />
<title>P2P WebRTC test (Rust signaling)</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    padding: 16px;
  }
  video {
    width: 48%;
    background: #d5d5d5;
    aspect-ratio: 16/9;
  }
  .row {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
  }
  #log {
    white-space: pre-wrap;
    background: #0b1020;
    color: #d6e4ff;
    padding: 8px;
    border-radius: 8px;
    max-height: 40vh;
    overflow: auto;
  }
</style>

<h2>P2P WebRTC test (Rust signaling)</h2>
<div class="row">
  <input id="room" value="abc" />
  <button onclick="connect()">Connect</button>
  <button onclick="bye()">Bye</button>
  <button id="muteBtn" onclick="toggleMute()" disabled>Mute Audio</button>
  <button onclick="getConnectionStats()">Refresh Stats</button>
  <span>Role: <b id="role">—</b></span>
</div>

<div class="row">
  <video id="local" playsinline muted></video>
  <video id="remote" playsinline></video>
</div>

<h3>ICE Candidates</h3>
<div id="iceInfo">
  <div>
    <strong>Connection Type:</strong> <span id="connectionType">—</span>
  </div>
  <div>
    <strong>Active Candidate:</strong> <span id="activeCandidate">—</span>
  </div>
  <div>
    <strong>Total Candidates:</strong> <span id="candidateCount">0</span>
  </div>
</div>

<h3>Log</h3>
<pre id="log"></pre>

<script>
  const WS_URL =
    (location.protocol === "https:" ? "wss://" : "ws://") +
    location.host +
    "/ws";
  let ws,
    pc,
    localStream,
    role = null;
  let haveLocalMedia = false;
  let pendingIce = [];
  let isMuted = false;
  let iceCandidates = [];
  let activeCandidate = null;

  const localEl = document.getElementById("local");
  const remoteEl = document.getElementById("remote");

  function setupWebRTCHandlers() {
    pc.ontrack = async (e) => {
      if (e.streams[0]) {
        const stream = e.streams[0];
        remoteEl.srcObject = stream;
        const audioTracks = stream.getAudioTracks();
        const videoTracks = stream.getVideoTracks();

        log(`received remote stream with ${stream.getTracks().length} tracks`);

        stream.getTracks().forEach((t) => {
          log(`received track ${t.label} ${t.kind}`);
        });

        try {
          await remoteEl.play();
          log("✅ remote video+audio playing successfully");
        } catch (err) {
          log("❌ remote.play blocked:", err.message);
          log("💡 Click anywhere to start video");

          // Add click handler to play video
          const playVideo = async () => {
            try {
              await remoteEl.play();
              log("✅ Remote video playing after user interaction");
            } catch (e) {
              log("❌ Still blocked after user interaction:", e.message);
            }
          };

          document.addEventListener("click", playVideo, { once: true });
        }
      }
    };

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        // Track ICE candidates
        iceCandidates.push({
          type: e.candidate.type,
          protocol: e.candidate.protocol,
          address: e.candidate.address,
          port: e.candidate.port,
          candidateType: e.candidate.candidateType || e.candidate.type,
        });

        // Update UI
        updateIceInfo();

        // Log candidate
        // log(
        //   `ICE candidate: ${e.candidate.type} ${e.candidate.protocol} ${e.candidate.address}:${e.candidate.port}`
        // );

        send({ type: "ice", candidate: e.candidate });
      } else {
        log("ICE gathering complete");
      }
    };

    // Monitor connection state
    pc.onconnectionstatechange = () => {
      log(`[onconnectionstatechange] connection state: ${pc.connectionState}`);
      if (pc.connectionState === "connected") {
        log("✅ Two-way communication established!");
        // Get connection stats to see which candidate is being used
        setTimeout(() => getConnectionStats(), 1000); // Wait a bit for stats to be ready
      }
    };
  }

  async function fetchIceServers() {
    // Get TURN server credentials dynamically using Metered.ca API
    let iceServers = [
      // STUN servers for NAT traversal (comment out for TURN-only testing)
      // { urls: "stun:stun.l.google.com:19302" },
      // { urls: "stun:stun1.l.google.com:19302" },
    ];

    // Try to get dynamic TURN servers from Metered.ca API
    try {
      const response = await fetch(
        "https://irisa.metered.live/api/v1/turn/credentials?apiKey=6437b90b4a436acebe12a1533600f6eb021f"
      );
      const dynamicIceServers = await response.json();

      // Use all servers from API (both STUN and TURN)
      iceServers = [...iceServers, ...dynamicIceServers];
    } catch (e) {
      log("⚠️ Failed to fetch dynamic TURN servers:", e.message);
      log("🔄 Falling back to static TURN servers");

      // Fallback to static TURN servers
      iceServers.push(
        {
          urls: "turn:openrelay.metered.ca:80",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:openrelay.metered.ca:443",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:openrelay.metered.ca:443?transport=tcp",
          username: "openrelayproject",
          credential: "openrelayproject",
        },
        {
          urls: "turn:relay1.expressturn.com:3480",
          username: "efPU52K4SLOQ34W2QY",
          credential: "1TJPNFxHKXrZfelz",
        }
      );
    }

    return iceServers;
  }

  async function connect() {
    const roomId = document.getElementById("room").value.trim();
    if (!roomId) return alert("enter room id");

    // Reset ICE info
    iceCandidates = [];
    activeCandidate = null;
    document.getElementById("connectionType").textContent = "—";
    document.getElementById("activeCandidate").textContent = "—";
    document.getElementById("candidateCount").textContent = "0";
    // Enable mute button
    document.getElementById("muteBtn").disabled = false;

    let iceServers = await fetchIceServers();

    // log("🔍 Final iceServers being used:", JSON.stringify(iceServers, null, 2));
    pc = new RTCPeerConnection({
      iceServers: iceServers,
      iceCandidatePoolSize: 5, // Pre-gather ICE candidates for faster connection
    });

    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      haveLocalMedia = true;
    } catch (e) {
      log("getUserMedia failed:", e.message || e);
      return;
    }

    localEl.srcObject = localStream;
    localStream.getVideoTracks()[0].applyConstraints({ aspectRatio: 16 / 9 });
    localEl.play().catch(() => {});

    localStream.getTracks().forEach((t) => {
      pc.addTrack(t, localStream);
      log(`added track ${t.label} ${t.kind}`);
    });

    setupWebRTCHandlers();

    ws = new WebSocket(`${WS_URL}?roomId=${encodeURIComponent(roomId)}`);
    ws.onopen = () => log("[WebSocket] open");
    ws.onclose = (e) => log("[WebSocket] close", e.code, e.reason || "");
    ws.onerror = (e) => log("[WebSocket] error", e.message || e);
    ws.onmessage = async (ev) => {
      let msg;
      try {
        msg = JSON.parse(ev.data);
        log(
          `[received] ${msg.type}:`,
          JSON.stringify(msg).substring(0, 200) + "..."
        );
      } catch (e) {
        return log("drop non-JSON", ev.data, e);
      }

      if (msg.type === "role") {
        role = msg.role;
        log(`received role message: ${role}`);
        document.getElementById("role").textContent = role;
        return;
      }

      if (msg.type === "room" && msg.event === "peer-joined") {
        log(`peer joined → room now has ${msg.peerCount} peers`);
        log(
          `Debug: role=${role}, signalingState=${pc?.signalingState}, haveLocalMedia=${haveLocalMedia}`
        );
        if (role === "host" && msg.peerCount > 1 && haveLocalMedia) {
          // If WebRTC connection is closed, create a new one
          if (!pc || pc.connectionState === "closed") {
            log("Creating new WebRTC connection for rejoining peer");
            let iceServers = await fetchIceServers();
            pc = new RTCPeerConnection({
              iceServers: iceServers,
              iceCandidatePoolSize: 5,
            });

            // Re-add tracks to new connection
            localStream.getTracks().forEach((t) => {
              pc.addTrack(t, localStream);
            });

            // Re-setup event handlers
            setupWebRTCHandlers();
          }

          if (pc.signalingState === "stable") {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            log("sending [offer]");
            send({ type: "offer", sdp: offer.sdp });
          }
        }
        return;
      }

      if (msg.type === "offer") {
        await pc.setRemoteDescription({ type: "offer", sdp: msg.sdp });
        while (pendingIce.length) {
          await pc.addIceCandidate(pendingIce.shift());
        }
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        log("sending [answer]");
        send({ type: "answer", sdp: answer.sdp });
        return;
      }

      if (msg.type === "answer") {
        await pc.setRemoteDescription({ type: "answer", sdp: msg.sdp });
        while (pendingIce.length) {
          await pc.addIceCandidate(pendingIce.shift());
        }
        return;
      }

      if (msg.type === "ice") {
        const c = msg.candidate;
        if (pc.remoteDescription) {
          try {
            await pc.addIceCandidate(c);
          } catch (e) {
            log("addIceCandidate err", e);
          }
        } else {
          pendingIce.push(c);
        }
        return;
      }

      if (msg.type === "bye") {
        log("peer said bye → closing");
        await cleanup("peer-bye");
        return;
      }

      if (msg.type === "peer-left") {
        log("peer left unexpectedly → staying in room, ready for new peer");
        // Don't cleanup - stay in room for new peer to join
        // Just clear the remote video and reset WebRTC state
        remoteEl.srcObject = null;
        if (pc) {
          pc.close();
          pc = null;
        }
        // Update role from server message
        role = msg.newRole || "host";
        document.getElementById("role").textContent = role;
        // Reset pending ICE candidates
        pendingIce = [];
        // Reset ICE info display
        iceCandidates = [];
        activeCandidate = null;
        document.getElementById("connectionType").textContent = "—";
        document.getElementById("activeCandidate").textContent = "—";
        document.getElementById("candidateCount").textContent = "0";
        log(
          `🔄 Ready for new peer to join (waiting for room.ready)... Role: ${role}`
        );
        return;
      }
    };
  }

  async function bye() {
    await cleanup("self-bye");
  }

  function toggleMute() {
    if (!localStream) return;

    const audioTracks = localStream.getAudioTracks();
    if (audioTracks.length > 0) {
      isMuted = !isMuted;
      audioTracks[0].enabled = !isMuted; // false = muted, true = unmuted

      const muteBtn = document.getElementById("muteBtn");
      muteBtn.textContent = isMuted ? "Unmute Audio" : "Mute Audio";
      log(
        isMuted
          ? "Audio muted (local + remote)"
          : "Audio unmuted (local + remote)"
      );
    }
  }

  async function cleanup(tag) {
    if (tag === "self-bye") {
      send({ type: "bye" });
      try {
        ws?.close();
      } catch {}
      ws = null;
    }

    try {
      pc?.close();
    } catch {}
    pc = null;

    remoteEl.srcObject = null;
    role = null;
    pendingIce = [];

    // Reset UI
    document.getElementById("role").textContent = "—";
    document.getElementById("muteBtn").disabled = true;
    document.getElementById("muteBtn").textContent = "Mute Audio";
    isMuted = false;

    log("cleanup complete:", tag);
  }

  function send(obj) {
    const s = JSON.stringify(obj);
    ws?.send(s);
  }

  function updateIceInfo() {
    document.getElementById("candidateCount").textContent =
      iceCandidates.length;
  }

  async function getConnectionStats() {
    try {
      const stats = await pc.getStats();
      let connectionType = "Unknown";
      let activeCandidateInfo = "Unknown";

      // First, collect all individual candidate reports
      const candidateReports = new Map();
      let totalCandidatesCount = 0;

      stats.forEach((report) => {
        if (
          report.type === "local-candidate" ||
          report.type === "remote-candidate"
        ) {
          candidateReports.set(report.id, report);
          totalCandidatesCount++;
        }
      });

      // Update total candidates count in UI
      document.getElementById("candidateCount").textContent =
        totalCandidatesCount;

      // Log all candidate reports to see what we have
      log(`🔍 Found ${totalCandidatesCount} individual candidate reports:`);
      candidateReports.forEach((candidate, id) => {
        log(
          `   ${id}: ${candidate.candidateType} ${candidate.address}:${candidate.port}`
        );
      });

      stats.forEach((report) => {
        if (report.type === "candidate-pair" && report.state === "succeeded") {
          log(`🔍 Found succeeded candidate pair: ${report.id}`);
          log(`   Local candidate ID: ${report.localCandidateId}`);
          log(`   Remote candidate ID: ${report.remoteCandidateId}`);

          // Look up the actual candidate objects from our map
          const localCandidate = candidateReports.get(report.localCandidateId);
          const remoteCandidate = candidateReports.get(
            report.remoteCandidateId
          );

          let localType = "unknown";
          let remoteType = "unknown";

          if (localCandidate) {
            localType = localCandidate.candidateType || "unknown";
            log(
              `   Local candidate: ${localType} ${localCandidate.address}:${localCandidate.port}`
            );
          } else {
            log(`   ❌ Local candidate not found: ${report.localCandidateId}`);
          }

          if (remoteCandidate) {
            remoteType = remoteCandidate.candidateType || "unknown";
            log(
              `   Remote candidate: ${remoteType} ${remoteCandidate.address}:${remoteCandidate.port}`
            );
          } else {
            log(
              `   ❌ Remote candidate not found: ${report.remoteCandidateId}`
            );
          }

          log(`✅ Extracted - Local: ${localType}, Remote: ${remoteType}`);

          // Determine connection type based on the combination
          if (localType === "relay" || remoteType === "relay") {
            connectionType = "🔄 TURN Relay";
          } else if (localType === "host" && remoteType === "host") {
            connectionType = "🏠 Direct (Local)";
          } else if (
            localType === "srflx" ||
            remoteType === "srflx" ||
            localType === "prflx" ||
            remoteType === "prflx"
          ) {
            connectionType = "🌐 STUN (Public IP)";
          } else {
            connectionType = "🔗 Mixed Connection";
          }

          activeCandidateInfo = `${localType} ↔ ${remoteType}`;
          activeCandidate = {
            local: localType,
            remote: remoteType,
            address: localCandidate?.address || "Unknown",
          };
        }
      });

      // Update UI
      document.getElementById("connectionType").textContent = connectionType;
      document.getElementById("activeCandidate").textContent =
        activeCandidateInfo;

      log(`📊 Connection: ${connectionType} (${activeCandidateInfo})`);

      // Also update the global variables for other functions
      window.currentConnectionType = connectionType;
      window.currentActiveCandidate = activeCandidateInfo;
    } catch (e) {
      log("Failed to get connection stats:", e.message);
    }
  }

  const log = (...a) => {
    const el = document.getElementById("log");
    el.textContent += a.join(" ") + "\n";
    el.scrollTop = el.scrollHeight;
  };
</script>
