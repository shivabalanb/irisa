<!doctype html>
<meta charset="utf-8" />
<title>P2P WebRTC test (Rust signaling)</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    padding: 16px;
  }
  video {
    width: 48%;
    background: #d5d5d5;
    aspect-ratio: 16/9;
  }
  .row {
    display: flex;
    gap: 12px;
    align-items: center;
    flex-wrap: wrap;
  }
  #log {
    white-space: pre-wrap;
    background: #0b1020;
    color: #d6e4ff;
    padding: 8px;
    border-radius: 8px;
    max-height: 40vh;
    overflow: auto;
  }
</style>

<h2>P2P WebRTC test (Rust signaling)</h2>
<div class="row">
  <input id="room" value="abc" />
  <button onclick="connect()">Connect</button>
  <button onclick="hangup()">Hang up (bye)</button>
  <button id="muteBtn" onclick="toggleMute()" disabled>Mute Audio</button>
  <span>Role: <b id="role">—</b></span>
</div>

<div class="row">
  <video id="local" playsinline muted></video>
  <video id="remote" playsinline></video>
</div>

<h3>Log</h3>
<pre id="log"></pre>

<script>
  const WS_URL =
    (location.protocol === "https:" ? "wss://" : "ws://") +
    location.host +
    "/ws";
  let ws,
    pc,
    localStream,
    role = null;
  let haveLocalMedia = false;
  let pendingIce = [];
  let isMuted = false;

  const localEl = document.getElementById("local");
  const remoteEl = document.getElementById("remote");

  async function connect() {
    const roomId = document.getElementById("room").value.trim();
    if (!roomId) return alert("enter room id");

    pc = new RTCPeerConnection();

    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      haveLocalMedia = true;
    } catch (e) {
      log("getUserMedia failed:", e.message || e);
      return;
    }

    localEl.srcObject = localStream;
    localStream.getVideoTracks()[0].applyConstraints({ aspectRatio: 16 / 9 });
    localEl.play().catch(() => {});

    // Enable mute button
    document.getElementById("muteBtn").disabled = false;

    localStream.getTracks().forEach((t) => {
      pc.addTrack(t, localStream);
      log(`added track ${t.label} ${t.kind}`);
    });

    pc.ontrack = async (e) => {
      if (e.streams[0]) {
        const stream = e.streams[0];
        remoteEl.srcObject = stream;
        const audioTracks = stream.getAudioTracks();
        const videoTracks = stream.getVideoTracks();

        log(`received remote stream with ${stream.getTracks().length} tracks`);

        stream.getTracks().forEach((t) => {
          log(`received track ${t.label} ${t.kind}`);
        });

        try {
          await remoteEl.play();
          log("remote video+audio playing successfully");
        } catch (err) {
          log("remote.play blocked:", err.message);
        }
      }
    };

    pc.onicecandidate = (e) => {
      if (e.candidate) send({ type: "ice", candidate: e.candidate });
    };

    // Monitor connection state
    pc.onconnectionstatechange = () => {
      log(`[onconnectionstatechange] connection state: ${pc.connectionState}`);
      if (pc.connectionState === "connected") {
        log("✅ Two-way communication established!");
      }
    };

    ws = new WebSocket(`${WS_URL}?roomId=${encodeURIComponent(roomId)}`);
    ws.onopen = () => log("[WebSocket] open");
    ws.onclose = (e) => log("[WebSocket] close", e.code, e.reason || "");
    ws.onerror = (e) => log("[WebSocket] error", e.message || e);
    ws.onmessage = async (ev) => {
      let msg;
      try {
        msg = JSON.parse(ev.data);
      } catch (e) {
        return log("drop non-JSON", ev.data, e);
      }

      if (msg.type === "role") {
        role = msg.role;
        document.getElementById("role").textContent = role;
        if (role === "host") log("waiting for peer to join (room.ready)...");
        return;
      }

      if (role === "host" && msg.type === "room" && msg.status === "ready") {
        if (pc.signalingState === "stable" && haveLocalMedia) {
          log("room ready → creating offer");
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          send({ type: "offer", sdp: offer.sdp });
        }
        return;
      }

      if (msg.type === "offer") {
        log("received offer → sent answer");

        await pc.setRemoteDescription({ type: "offer", sdp: msg.sdp });
        while (pendingIce.length) {
          await pc.addIceCandidate(pendingIce.shift());
        }
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        send({ type: "answer", sdp: answer.sdp });
      } else if (msg.type === "answer") {
        log("received answer");

        await pc.setRemoteDescription({ type: "answer", sdp: msg.sdp });
        while (pendingIce.length) {
          await pc.addIceCandidate(pendingIce.shift());
        }
      } else if (msg.type === "ice") {
        log("received ice candidate", msg.candidate);

        const c = msg.candidate;
        if (pc.remoteDescription) {
          try {
            await pc.addIceCandidate(c);
          } catch (e) {
            log("addIceCandidate err", e);
          }
        } else {
          pendingIce.push(c);
        }
      } else if (msg.type === "bye") {
        log("peer said bye → closing");
        await cleanup("peer-bye");
      }
    };
  }

  async function hangup() {
    send({ type: "bye" });
    await cleanup("self-bye");
  }

  function toggleMute() {
    if (!localStream) return;

    const audioTracks = localStream.getAudioTracks();
    if (audioTracks.length > 0) {
      isMuted = !isMuted;
      audioTracks[0].enabled = !isMuted; // false = muted, true = unmuted

      const muteBtn = document.getElementById("muteBtn");
      muteBtn.textContent = isMuted ? "Unmute Audio" : "Mute Audio";
      log(
        isMuted
          ? "Audio muted (local + remote)"
          : "Audio unmuted (local + remote)"
      );
    }
  }

  async function cleanup(tag) {
    try {
      ws?.close();
    } catch {}
    ws = null;

    try {
      pc?.close();
    } catch {}
    pc = null;

    // Stop and clear local media
    // if (localStream) {
    //   localStream.getTracks().forEach((t) => t.stop());
    //   localStream = null;
    // }

    // Clear video elements
    // localEl.srcObject = null;
    remoteEl.srcObject = null;

    // Reset state variables
    // haveLocalMedia = false;
    role = null;
    pendingIce = [];

    // Reset UI
    document.getElementById("role").textContent = "—";
    document.getElementById("muteBtn").disabled = true;
    document.getElementById("muteBtn").textContent = "Mute Audio";
    isMuted = false;

    log("cleanup complete:", tag);
  }

  function send(obj) {
    const s = JSON.stringify(obj);
    ws?.send(s);
    if (obj.sdp === undefined) {
      log("[send]", s);
    } else {
      log("[send]", obj.type);
    }
  }

  const log = (...a) => {
    const el = document.getElementById("log");
    el.textContent += a.join(" ") + "\n";
    el.scrollTop = el.scrollHeight;
  };
</script>
